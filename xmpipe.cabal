build-type:	Simple
cabal-version:	>= 1.8

name:		xmpipe
version:	0.0.0.0
stability:	Experimental
author:		Yoshikuni Jujo <PAF01143@nifty.ne.jp>
maintainer:	Yoshikuni Jujo <PAF01143@nifty.ne.jp>
homepage:	https://github.com/YoshikuniJujo/xmpipe/wiki

license:	BSD3
license-file:	LICENSE

category:	Network
synopsis:	XMPP implementation using simple-PIPE
description:
    Example programs
    .
    Client
    .
    examples/simpleClient.hs
    .
    > % runhaskell simpleClient.hs yoshikuni@localhost/im password yoshio@localhost
    > Hello, my name is Yoshikuni!
    > yoshio@localhost: Hi, I'm Yoshio.
    > yoshio@localhost: I am busy.
    > Good-bye!
    > /quit
    .
    extensions
    .
    * OverloadedStrings
    .
    * PackageImports
    .
    replace
    .
    * &#38;&#35;123; to '&#123;'
    .
    * &#38;&#35;125; to '&#125;'
    .
    > import Prelude hiding (filter)
    >
    > import Control.Applicative
    > import "monads-tf" Control.Monad.State
    > import "monads-tf" Control.Monad.Writer
    > import Control.Concurrent hiding (yield)
    > import Data.Maybe
    > import Data.Pipe
    > import Data.Pipe.Flow
    > import Data.Pipe.ByteString
    > import System.IO
    > import System.Environment
    > import Text.XML.Pipe
    > import Network
    > import Network.Sasl
    > import Network.XMPiPe.Core.C2S.Client
    >
    > import qualified Data.ByteString as BS
    > import qualified Data.ByteString.Char8 as BSC
    >
    > mechanisms :: [BS.ByteString]
    > mechanisms = ["SCRAM-SHA-1", "DIGEST-MD5", "PLAIN"]
    >
    > data St = St [(BS.ByteString, BS.ByteString)]
    > instance SaslState St where getSaslState (St ss) = ss; putSaslState ss _ = St ss
    >
    > main :: IO ()
    > main = do
    > 	(me_ : pw : you_ : _) <- map BSC.pack <$> getArgs
    > 	let	me@(Jid un d (Just rsc)) = toJid me_; you = toJid you_
    > 		ss = St [
    > 			("username", un), ("authcid", un), ("password", pw),
    > 			("cnonce", "00DEADBEEF00") ]
    > 	h <- connectTo (BSC.unpack d) $ PortNumber 5222
    > 	void . (`evalStateT` ss) . runPipe $
    > 		fromHandle h =$= sasl d mechanisms =$= toHandle h
    > 	(Just ns, _fts) <- runWriterT . runPipe $
    > 		fromHandle h =$= bind d rsc =@= toHandle h
    > 	void . forkIO . void . runPipe $ fromHandle h =$= input ns
    > 		=$= convert fromMessage =$= filter isJust =$= convert fromJust
    > 		=$= toHandleLn stdout
    > 	void . (`runStateT` 0) . runPipe $ do
    > 		yield (presence me) =$= output =$= toHandle h
    > 		fromHandleLn stdin =$= before (== "/quit")
    > 			=$= mkMessage you =$= output =$= toHandle h
    > 		yield End =$= output =$= toHandle h
    >
    > presence :: Jid -> Mpi
    > presence me = Presence
    > 	(tagsNull &#123; tagFrom = Just me &#125;) [XmlNode (nullQ "presence") [] [] []]
    >
    > mkMessage :: Jid -> Pipe BS.ByteString Mpi (StateT Int IO) ()
    > mkMessage you = (await >>=) . maybe (return ()) $ \m -> do
    > 	n <- get; modify succ
    > 	yield $ toM n m
    > 	mkMessage you
    > 	where toM n msg = Message (tagsType "chat") &#123;
    > 			tagId = Just . BSC.pack . ("msg_" ++) $ show n,
    > 			tagTo = Just you &#125;
    > 		[XmlNode (nullQ "body") [] [] [XmlCharData msg]]
    >
    > fromMessage :: Mpi -> Maybe BS.ByteString
    > fromMessage (Message ts [XmlNode _ [] [] [XmlCharData m]])
    > 	| Just (Jid n d _) <- tagFrom ts = Just $ BS.concat [n, "@", d, ": ", m]
    > fromMessage _ = Nothing
    .

extra-source-files:
    examples/simpleClient.hs

library
    hs-source-dirs:	core
    exposed-modules:
        Network.XMPiPe.Core.C2S.Client,
        Network.XMPiPe.Core.C2S.Server,
        Network.XMPiPe.Core.S2S.Client,
        Network.XMPiPe.Core.S2S.Server
    other-modules:
        Xmpp, XmppType, Tools, SaslClient, SaslServer
    build-depends:
        base == 4.*, bytestring == 0.10.*, xml-pipe == 0.0.0.*,
        simple-pipe == 0.0.0.*, uuid == 1.3.*, base64-bytestring == 1.0.*,
        handle-like == 0.1.*, sasl == 0.0.0.*, monads-tf == 0.1.*
    ghc-options:	-Wall
    extensions:		PatternGuards, DoAndIfThenElse
